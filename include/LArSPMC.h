/**
 *  @file   LArRecoND/include/LArSPMC.h
 *
 *  @brief  Header file defining the "SpacePoint" (SP) format for Monte Carlo.
 *          Based on autogenerated ROOT code with Pandora-style edits
 *
 *  $Log: $
 */
#ifndef PANDORA_LAR_SPMC_H
#define PANDORA_LAR_SPMC_H 1

#include "LArSP.h"

#include "TChain.h"
#include "TFile.h"
#include "TROOT.h"

// Header file for the classes stored in the TTree if any.
#include <vector>

namespace lar_nd_reco
{

class LArSPMC : public LArSP
{
public:
    /**
     *  @brief  Constructor requiring TTree pointer
     *
     *  @param  tree The TTree pointer
     */
    LArSPMC(TTree *tree = nullptr);

    /**
     *  @brief  Destructor
     */
    virtual ~LArSPMC();

    /**
     *  @brief  Initialise using the input TTree
     *
     *  @param  tree The input TTree
     */
    virtual void InitMC(TTree *tree);

    // Hit level truth information
    std::vector<std::vector<int>> *m_hit_segmentID = nullptr;
    std::vector<std::vector<int>> *m_hit_segmentIndex = nullptr;
    std::vector<std::vector<int>> *m_hit_particleID = nullptr;
    std::vector<std::vector<int>> *m_hit_particleIndex = nullptr;
    std::vector<std::vector<int>> *m_hit_interactionIndex = nullptr;
    std::vector<std::vector<int>> *m_hit_pdg = nullptr;
    std::vector<std::vector<float>> *m_hit_packetFrac = nullptr;
    TBranch *m_b_hit_segmentID = nullptr;
    TBranch *m_b_hit_segmentIndex = nullptr;
    TBranch *m_b_hit_particleID = nullptr;
    TBranch *m_b_hit_particleIndex = nullptr;
    TBranch *m_b_hit_interactionIndex = nullptr;
    TBranch *m_b_hit_pdg = nullptr;
    TBranch *m_b_hit_packetFrac = nullptr;

    // MC Particle information
    std::vector<float> *m_mcp_energy = nullptr;
    std::vector<int> *m_mcp_pdg = nullptr;
    std::vector<int> *m_mcp_nuid = nullptr;
    std::vector<int> *m_mcp_id = nullptr;
    std::vector<int> *m_mcp_mother = nullptr;
    std::vector<float> *m_mcp_px = nullptr;
    std::vector<float> *m_mcp_py = nullptr;
    std::vector<float> *m_mcp_pz = nullptr;
    std::vector<float> *m_mcp_startx = nullptr;
    std::vector<float> *m_mcp_starty = nullptr;
    std::vector<float> *m_mcp_startz = nullptr;
    std::vector<float> *m_mcp_endx = nullptr;
    std::vector<float> *m_mcp_endy = nullptr;
    std::vector<float> *m_mcp_endz = nullptr;
    TBranch *m_b_mcp_energy = nullptr;
    TBranch *m_b_mcp_pdg = nullptr;
    TBranch *m_b_mcp_nuid = nullptr;
    TBranch *m_b_mcp_id = nullptr;
    TBranch *m_b_mcp_mother = nullptr;
    TBranch *m_b_mcp_px = nullptr;
    TBranch *m_b_mcp_py = nullptr;
    TBranch *m_b_mcp_pz = nullptr;
    TBranch *m_b_mcp_startx = nullptr;
    TBranch *m_b_mcp_starty = nullptr;
    TBranch *m_b_mcp_startz = nullptr;
    TBranch *m_b_mcp_endx = nullptr;
    TBranch *m_b_mcp_endy = nullptr;
    TBranch *m_b_mcp_endz = nullptr;

    // Neutrino information
    std::vector<int> *m_nuID = nullptr;
    std::vector<float> *m_nue = nullptr;
    std::vector<int> *m_nuPDG = nullptr;
    std::vector<float> *m_nupx = nullptr;
    std::vector<float> *m_nupy = nullptr;
    std::vector<float> *m_nupz = nullptr;
    std::vector<float> *m_nuvtxx = nullptr;
    std::vector<float> *m_nuvtxy = nullptr;
    std::vector<float> *m_nuvtxz = nullptr;
    std::vector<int> *m_mode = nullptr;
    std::vector<int> *m_ccnc = nullptr;
    TBranch *m_b_nuID = nullptr;
    TBranch *m_b_nue = nullptr;
    TBranch *m_b_nuPDG = nullptr;
    TBranch *m_b_nupx = nullptr;
    TBranch *m_b_nupy = nullptr;
    TBranch *m_b_nupz = nullptr;
    TBranch *m_b_nuvtxx = nullptr;
    TBranch *m_b_nuvtxy = nullptr;
    TBranch *m_b_nuvtxz = nullptr;
    TBranch *m_b_mode = nullptr;
    TBranch *m_b_ccnc = nullptr;
};

LArSPMC::LArSPMC(TTree *tree) : LArSP(tree)
{
    if (tree == nullptr)
    {
        std::cout << "Warning: null tree passed to LArSPMC" << std::endl;
    }
    InitMC(tree);
}

LArSPMC::~LArSPMC()
{
}

void LArSPMC::InitMC(TTree *tree)
{
    // The Init() function is called when the selector needs to initialize
    // a new tree or chain. Typically here the branch addresses and branch
    // pointers of the tree will be set.
    // It is normally not necessary to make changes to the generated
    // code, but the routine can be extended by the user if needed.
    // Init() will be called many times when running on PROOF
    // (once per file to be processed).

    // Set branch addresses and branch pointers
    if (!tree)
        return;
    m_fChain = tree;
    m_fCurrent = -1;
    m_fChain->SetMakeClass(1);

    m_fChain->SetBranchAddress("hit_segmentID", &m_hit_segmentID, &m_b_hit_segmentID);
    m_fChain->SetBranchAddress("hit_segmentIndex", &m_hit_segmentIndex, &m_b_hit_segmentIndex);
    m_fChain->SetBranchAddress("hit_particleID", &m_hit_particleID, &m_b_hit_particleID);
    m_fChain->SetBranchAddress("hit_particleIndex", &m_hit_particleIndex, &m_b_hit_particleIndex);
    m_fChain->SetBranchAddress("hit_interactionIndex", &m_hit_interactionIndex, &m_b_hit_interactionIndex);
    m_fChain->SetBranchAddress("hit_pdg", &m_hit_pdg, &m_b_hit_pdg);
    m_fChain->SetBranchAddress("hit_packetFrac", &m_hit_packetFrac, &m_b_hit_packetFrac);
    m_fChain->SetBranchAddress("mcp_energy", &m_mcp_energy, &m_b_mcp_energy);
    m_fChain->SetBranchAddress("mcp_pdg", &m_mcp_pdg, &m_b_mcp_pdg);
    m_fChain->SetBranchAddress("mcp_nuid", &m_mcp_nuid, &m_b_mcp_nuid);
    m_fChain->SetBranchAddress("mcp_id", &m_mcp_id, &m_b_mcp_id);
    m_fChain->SetBranchAddress("mcp_mother", &m_mcp_mother, &m_b_mcp_mother);
    m_fChain->SetBranchAddress("mcp_px", &m_mcp_px, &m_b_mcp_px);
    m_fChain->SetBranchAddress("mcp_py", &m_mcp_py, &m_b_mcp_py);
    m_fChain->SetBranchAddress("mcp_pz", &m_mcp_pz, &m_b_mcp_pz);
    m_fChain->SetBranchAddress("mcp_startx", &m_mcp_startx, &m_b_mcp_startx);
    m_fChain->SetBranchAddress("mcp_starty", &m_mcp_starty, &m_b_mcp_starty);
    m_fChain->SetBranchAddress("mcp_startz", &m_mcp_startz, &m_b_mcp_startz);
    m_fChain->SetBranchAddress("mcp_endx", &m_mcp_endx, &m_b_mcp_endx);
    m_fChain->SetBranchAddress("mcp_endy", &m_mcp_endy, &m_b_mcp_endy);
    m_fChain->SetBranchAddress("mcp_endz", &m_mcp_endz, &m_b_mcp_endz);
    m_fChain->SetBranchAddress("nuID", &m_nuID, &m_b_nuID);
    m_fChain->SetBranchAddress("nue", &m_nue, &m_b_nue);
    m_fChain->SetBranchAddress("nuPDG", &m_nuPDG, &m_b_nuPDG);
    m_fChain->SetBranchAddress("nupx", &m_nupx, &m_b_nupx);
    m_fChain->SetBranchAddress("nupy", &m_nupy, &m_b_nupy);
    m_fChain->SetBranchAddress("nupz", &m_nupz, &m_b_nupz);
    m_fChain->SetBranchAddress("nuvtxx", &m_nuvtxx, &m_b_nuvtxx);
    m_fChain->SetBranchAddress("nuvtxy", &m_nuvtxy, &m_b_nuvtxy);
    m_fChain->SetBranchAddress("nuvtxz", &m_nuvtxz, &m_b_nuvtxz);
    m_fChain->SetBranchAddress("mode", &m_mode, &m_b_mode);
    m_fChain->SetBranchAddress("ccnc", &m_ccnc, &m_b_ccnc);
}

} // namespace lar_nd_reco

#endif
